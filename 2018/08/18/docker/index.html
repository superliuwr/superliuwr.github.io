<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Docker | SUPERLOG</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="Concepts Images 一个只读模板，可以用来创建容器，一个镜像可以创建多个容器 Docker 提供了一个很简单的机制来创建和更新现有的镜像，甚至可以直接从其他人那里获取做好的镜像直接使用    docker 镜像代表了容器的文件系统里的内容，是容器的基础，镜像一般是通过 Dockerfile 生成的 docker 的镜像是分层的，所有的镜像（除了基础镜像）都是在之前镜像的基础上加上自己这">
<meta name="keywords" content="Docker">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker">
<meta property="og:url" content="http://superliuwr.github.io/2018/08/18/docker/index.html">
<meta property="og:site_name" content="SUPERLOG">
<meta property="og:description" content="Concepts Images 一个只读模板，可以用来创建容器，一个镜像可以创建多个容器 Docker 提供了一个很简单的机制来创建和更新现有的镜像，甚至可以直接从其他人那里获取做好的镜像直接使用    docker 镜像代表了容器的文件系统里的内容，是容器的基础，镜像一般是通过 Dockerfile 生成的 docker 的镜像是分层的，所有的镜像（除了基础镜像）都是在之前镜像的基础上加上自己这">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://superliuwr.github.io/2018/08/18/docker/docker-commands.webp">
<meta property="og:image" content="http://superliuwr.github.io/2018/08/18/docker/docker-file-system.png">
<meta property="og:updated_time" content="2018-08-22T13:32:53.791Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker">
<meta name="twitter:description" content="Concepts Images 一个只读模板，可以用来创建容器，一个镜像可以创建多个容器 Docker 提供了一个很简单的机制来创建和更新现有的镜像，甚至可以直接从其他人那里获取做好的镜像直接使用    docker 镜像代表了容器的文件系统里的内容，是容器的基础，镜像一般是通过 Dockerfile 生成的 docker 的镜像是分层的，所有的镜像（除了基础镜像）都是在之前镜像的基础上加上自己这">
<meta name="twitter:image" content="http://superliuwr.github.io/2018/08/18/docker/docker-commands.webp">
  
    <link rel="alternative" href="/atom.xml" title="SUPERLOG" type="application/atom+xml">
  
  
    <link rel="icon" href="images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div class="mobile-nav-panel">
	<i class="icon-reorder icon-large"></i>
</div>
<header id="header">
	<h1 class="blog-title">
		<a href="/">SUPERLOG</a>
	</h1>
	<nav class="nav">
		<ul>
			<li><a href="/">Home</a></li><li><a href="/categories/">Categories</a></li><li><a href="/tags/">Tags</a></li><li><a href="/archives">Archives</a></li><li><a href="/about">About</a></li>
			<li><a id="nav-search-btn" class="nav-icon" title="Search"></a></li>
			<li><a href="/atom.xml" id="nav-rss-link" class="nav-icon" title="RSS Feed"></a></li>
		</ul>
	</nav>
	<div id="search-form-wrap">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://superliuwr.github.io"></form>
	</div>
</header>
    <div id="main">
      <article id="post-docker" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2018/08/18/docker/" class="article-date">
  <time datetime="2018-08-18T13:30:30.000Z" itemprop="datePublished">2018-08-18</time>
</a>
		</span>
		<span class="meta-elements author">Marvin Liu</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 class="article-title entry-title" itemprop="name">
      Docker
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><p><img src="docker-commands.webp" alt="Docker Commands"></p>
<h3 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h3><ul>
<li>一个只读模板，可以用来创建容器，一个镜像可以创建多个容器</li>
<li>Docker 提供了一个很简单的机制来创建和更新现有的镜像，甚至可以直接从其他人那里获取做好的镜像直接使用</li>
</ul>
<p><img src="docker-file-system.png" alt="Docker File System"></p>
<ul>
<li>docker 镜像代表了容器的文件系统里的内容，是容器的基础，镜像一般是通过 Dockerfile 生成的</li>
<li>docker 的镜像是分层的，所有的镜像（除了基础镜像）都是在之前镜像的基础上加上自己这层的内容生成的</li>
<li>每一层镜像的元数据都是存在 json 文件中的，除了静态的文件系统之外，还会包含动态的数据</li>
</ul>
<h4 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h4><p>Search on Docker store<br><code>docker search mysql</code></p>
<p>Pull an image from Docker store<br><code>docker pull mysql:latest</code></p>
<p>Push an image to Docker store<br><code>docker push</code></p>
<p>List all downloaded images<br><code>docker images</code></p>
<p>Delete an image<br><code>docker rmi mysql</code><br><code>docker rmi mysql tomcat</code></p>
<p>Delete all iamges<br><code>docker rmi $(docker images -q)</code></p>
<p>Build an image from Dockerfile<br><code>docker build</code></p>
<p>Tag an image<br><code>docker tag</code></p>
<h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><ul>
<li>容器是从镜像创建的运行实例，也就是镜像启动后的一个实例称为容器，是独立运行的一个或一组应用。</li>
<li>docker 利用容器来运行应用，他可以被启动、开始、停止、删除，每个容器都是相互隔离的、保证安全的平台。</li>
</ul>
<h4 id="Commands-1"><a href="#Commands-1" class="headerlink" title="Commands"></a>Commands</h4><p>Create and Run a container from an image<br><code>docker run --name container-name -d image-name</code></p>
<p>List all running containers<br><code>docker ps</code></p>
<p>Stop a running container<br><code>docker stop container-name/container-id</code></p>
<p>Force stop a running container<br><code>docker kill container-name/container-id</code></p>
<blockquote>
<p>docker stop: Stop a running container (send SIGTERM, and then SIGKILL after grace period) […] The main process inside the container will receive SIGTERM, and after a grace period, SIGKILL. [emphasis mine]<br>docker kill: Kill a running container (send SIGKILL, or specified signal) […] The main process inside the container will be sent SIGKILL, or any signal specified with option –signal. [emphasis mine]</p>
</blockquote>
<p>Create a container but do not run it<br><code>docker create -t -i fedora bash</code></p>
<p>Start a container<br><code>docker start container-name/container-id</code></p>
<p>Restart a container<br><code>docker restart container-name/container-id</code></p>
<p>Delete a container<br><code>docker rm container-id</code></p>
<p>Delete all containers<br><code>docker rm $(docker ps -a -q )</code></p>
<p>Check logs<br><code>docker logs container-id/container-name</code></p>
<p>Attach to a running container<br><code>docker attach container-id</code></p>
<p>Run a command on a running container<br><code>docker exec -it container-id/container-name bash</code></p>
<p>List running processes on a container<br><code>docker top container-id</code></p>
<p>Inspect a container<br><code>docker insepct container-id</code></p>
<p>Copy file from host to container<br><code>docker cp 文件 container-id:目标文件/文件夹</code><br><code>docker cp /tmp/suzhuji.txt 7f237caad43b:/tmp</code></p>
<p>Copy file from container to host<br><code>docker cp container-id:目标文件/文件夹 宿主机目标文件/文件夹</code><br><code>docker cp 7f237caad43b:/tmp/yum.log /tmp</code></p>
<h3 id="Resoisitory"><a href="#Resoisitory" class="headerlink" title="Resoisitory"></a>Resoisitory</h3><ul>
<li>仓库是集中存放镜像文件的场所，类似 git 代码仓库等。</li>
<li>仓库（Respository）和仓库注册服务器（Registry）是有区别的。仓库注册服务器一般存放多个仓库，每个仓库又有多个镜像，每个镜像又有不同的标签（tag）。</li>
<li>仓库分为公开仓库（public）和私有仓库（private）两种形式。</li>
<li>当创建好自己的镜像后，可以通过 push 命令把它上传到公开或私有仓库。</li>
</ul>
<h2 id="Port-mappping"><a href="#Port-mappping" class="headerlink" title="Port mappping"></a>Port mappping</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Find IP address of container with ID &lt;container_id&gt; 通过容器 id 获取 ip</span></span><br><span class="line">$ sudo docker inspect &lt;container_id&gt; | grep IPAddress | cut -d ’<span class="string">"’ -f 4</span></span><br></pre></td></tr></table></figure>
<h3 id="自动映射端口"><a href="#自动映射端口" class="headerlink" title="自动映射端口"></a>自动映射端口</h3><p>-P 使用时需要指定 –expose 选项，指定需要对外提供服务的端口</p>
<p><code>$ sudo docker run -t -P --expose 22 --name server  ubuntu:14.04</code><br>使用 docker run -P 自动绑定所有对外提供服务的容器端口，映射的端口将会从没有使用的端口池中 (49000..49900) 自动选择，你可以通过 docker ps 、docker inspect &lt;container_id&gt; 或者 docker port &lt;container_id&gt; <port> 确定具体的绑定信息。</port></p>
<h3 id="绑定端口到指定接口"><a href="#绑定端口到指定接口" class="headerlink" title="绑定端口到指定接口"></a>绑定端口到指定接口</h3><p><code>$ sudo docker run -p [([&lt;host_interface&gt;:[host_port]])|(&lt;host_port&gt;):]&lt;container_port&gt;[/udp] &lt;image&gt; &lt;cmd&gt;</code><br>默认不指定绑定 ip 则监听所有网络接口。</p>
<p>绑定 TCP 端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bind TCP port 8080 of the container to TCP port 80 on 127.0.0.1 of the host machine.</span></span><br><span class="line">$ sudo docker run -p 127.0.0.1:80:8080 &lt;image&gt; &lt;cmd&gt;</span><br><span class="line"><span class="comment"># Bind TCP port 8080 of the container to a dynamically allocated TCP port on 127.0.0.1 of the host machine.</span></span><br><span class="line">$ sudo docker run -p 127.0.0.1::8080 &lt;image&gt; &lt;cmd&gt;</span><br><span class="line"><span class="comment"># Bind TCP port 8080 of the container to TCP port 80 on all available interfaces of the host machine.</span></span><br><span class="line">$ sudo docker run -p 80:8080 &lt;image&gt; &lt;cmd&gt;</span><br><span class="line"><span class="comment"># Bind TCP port 8080 of the container to a dynamically allocated TCP port on all available interfaces</span></span><br><span class="line">$ sudo docker run -p 8080 &lt;image&gt; &lt;cmd&gt;</span><br></pre></td></tr></table></figure></p>
<p>绑定 UDP 端口<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Bind UDP port 5353 of the container to UDP port 53 on 127.0.0.1 of the host machine.</span></span><br><span class="line">$ sudo docker run -p 127.0.0.1:53:5353/udp &lt;image&gt; &lt;cmd&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h2><p>Docker 四种网络模式</p>
<h3 id="host-模式"><a href="#host-模式" class="headerlink" title="host 模式"></a>host 模式</h3><p>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</p>
<p>例如，我们在 10.10.101.105/24 的机器上用 host 模式启动一个含有 web 应用的 Docker 容器，监听 tcp 80 端口。当我们在容器中执行任何类似 ifconfig 命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用 10.10.101.105:80 即可，不用任何 NAT 转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<h3 id="container-模式"><a href="#container-模式" class="headerlink" title="container 模式"></a>container 模式</h3><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<h3 id="none模式"><a href="#none模式" class="headerlink" title="none模式"></a>none模式</h3><p>这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p>
<h3 id="bridge模式"><a href="#bridge模式" class="headerlink" title="bridge模式"></a>bridge模式</h3><p>bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network Namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。当 Docker server 启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配 IP 了，Docker 会从 RFC1918 所定义的私有 IP 网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到 docker0 的容器就从这个子网中选择一个未占用的 IP 使用。如一般 Docker 会使用 172.17.0.0/16 这个网段，并将 172.17.42.1/16 分配给 docker0 网桥（在主机上使用 ifconfig 命令是可以看到 docker0 的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）</p>
<h2 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h2><h3 id="Data-Volume"><a href="#Data-Volume" class="headerlink" title="Data Volume"></a>Data Volume</h3><p>数据卷的使用其实和 Linux 挂载文件目录是很相似的。简单来说，数据卷就是一个可以供容器使用的特殊目录。</p>
<p><code>sudo docker run -ti --name volume1 -v /myDir ubuntu:16.04 bash</code><br><code>sudo docker run -ti --name volume2 -v /home/zsc/Music/:/myShare ubuntu:16.04 bash</code><br><code>sudo docker run -ti --name volume2 -v /home/zsc/Music/:/myShare:ro ubuntu:16.04 bash</code></p>
<p>数据卷是用来持久化数据的，所以数据卷的生命周期独立于容器。所以在容器结束后数据卷并不会被删除，如果你希望删除数据卷，可以在使用 <code>docker rm</code> 命令删除容器的时候加上 -v 参数。</p>
<p>值得注意的是，如果你删除挂载某个数据卷的所有容器的同时没有使用 -v 参数清理这些容器挂载的数据卷，你之后再想清理这些数据卷会很麻烦，所以在你确定某个数据卷没有必要存在的时候，在删除最后一个挂载这个数据卷的容器的时候，使用 -v 参数删除这个数据卷。</p>
<h3 id="Data-Volume-Container"><a href="#Data-Volume-Container" class="headerlink" title="Data Volume Container"></a>Data Volume Container</h3><p>所谓数据卷容器，其实就是一个普通的容器，只不过这个容器专门作为数据卷供其它容器挂载。</p>
<p>首先，在运行 docker run 指令的时候使用 -v 参数创建一个数据卷容器（这和我们之前创建数据卷的指令是一样的）：<br><code>sudo docker run -ti  -d -v /dataVolume --name v0 ubuntu:16.04</code></p>
<p>然后，创建一个新的容器挂载刚才创建的数据卷容器中的数据卷：使用 –volumes-from 参数<br><code>sudo docker run -ti --volumes-from v0 --name v1 ubuntu:16.04 bash</code></p>
<h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><h3 id="Clean-disk-space-used-by-Docker"><a href="#Clean-disk-space-used-by-Docker" class="headerlink" title="Clean disk space used by Docker"></a>Clean disk space used by Docker</h3><ul>
<li><code>docker system df</code></li>
<li><code>docker system prune</code></li>
<li><code>docker system prune -a</code></li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://blog.opskumu.com/docker.html" target="_blank" rel="noopener">Docker 学习笔记</a></li>
<li><a href="http://dockone.io/article/783" target="_blank" rel="noopener">10张图带你深入理解Docker容器和镜像</a></li>
<li><a href="https://www.huweihuang.com/article/docker/docker-commands-principle/" target="_blank" rel="noopener">Docker常用命令原理图</a></li>
</ul>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
  <div class="article-category">
    <a class="article-category-link" href="/categories/DevOps/">DevOps</a>
  </div>

			</span>
			<span class="tags">
				
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li></ul>

			</span>
		</div>
	</footer>
	
    
<nav id="article-nav">
  
    <a href="/2018/08/20/dockerfile/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Dockerfile
        
      </div>
    </a>
  
  
    <a href="/2018/08/16/kubernetes-ingress/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          Kubernetes Ingress and Traefik
        
      </div>
    </a>
  
</nav>

  
</article>




    </div>
    <div class="mb-search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:superliuwr.github.io">
  </form>
</div>
<footer id="footer">
	<h1 class="footer-blog-title">
		<a href="/">SUPERLOG</a>
	</h1>
	<span class="copyright">
		&copy; 2018 Marvin Liu<br>
		Modify from <a href="http://sanographix.github.io/tumblr/apollo/" target="_blank">Apollo</a> theme, designed by <a href="http://www.sanographix.net/" target="_blank">SANOGRAPHIX.NET</a><br>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	</span>
</footer>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>