<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Node.js Error Handling Best Practices | SUPERLOG</title>
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="Error hanldingError typesIn Node, errors occur any of the following ways:">
<meta name="keywords" content="Node.js,Error Handling,Best Practices">
<meta property="og:type" content="article">
<meta property="og:title" content="Node.js Error Handling Best Practices">
<meta property="og:url" content="http://superliuwr.github.io/2018/07/01/nodejs-error-handling/index.html">
<meta property="og:site_name" content="SUPERLOG">
<meta property="og:description" content="Error hanldingError typesIn Node, errors occur any of the following ways:">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-07-19T13:35:51.744Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Node.js Error Handling Best Practices">
<meta name="twitter:description" content="Error hanldingError typesIn Node, errors occur any of the following ways:">
  
    <link rel="alternative" href="/atom.xml" title="SUPERLOG" type="application/atom+xml">
  
  
    <link rel="icon" href="images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>
<body>
  <div id="container">
    <div class="mobile-nav-panel">
	<i class="icon-reorder icon-large"></i>
</div>
<header id="header">
	<h1 class="blog-title">
		<a href="/">SUPERLOG</a>
	</h1>
	<nav class="nav">
		<ul>
			<li><a href="/">Home</a></li><li><a href="/categories/">Categories</a></li><li><a href="/tags/">Tags</a></li><li><a href="/archives">Archives</a></li><li><a href="/about">About</a></li>
			<li><a id="nav-search-btn" class="nav-icon" title="Search"></a></li>
			<li><a href="/atom.xml" id="nav-rss-link" class="nav-icon" title="RSS Feed"></a></li>
		</ul>
	</nav>
	<div id="search-form-wrap">
		<form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://superliuwr.github.io"></form>
	</div>
</header>
    <div id="main">
      <article id="post-nodejs-error-handling" class="post">
	<footer class="entry-meta-header">
		<span class="meta-elements date">
			<a href="/2018/07/01/nodejs-error-handling/" class="article-date">
  <time datetime="2018-07-01T01:09:47.000Z" itemprop="datePublished">2018-07-01</time>
</a>
		</span>
		<span class="meta-elements author">Marvin Liu</span>
		<div class="commentscount">
			
		</div>
	</footer>
	
	<header class="entry-header">
		
  
    <h1 class="article-title entry-title" itemprop="name">
      Node.js Error Handling Best Practices
    </h1>
  

	</header>
	<div class="entry-content">
		
    	<h1 id="Error-hanlding"><a href="#Error-hanlding" class="headerlink" title="Error hanlding"></a>Error hanlding</h1><h2 id="Error-types"><a href="#Error-types" class="headerlink" title="Error types"></a>Error types</h2><p>In Node, errors occur any of the following ways:</p>
<a id="more"></a>
<ul>
<li>Explicit exceptions (those triggered by the throw keyword)</li>
<li>Implicit exceptions (like ReferenceError: foo not defined)</li>
<li>The ‘error’ event (which may trigger an exception)</li>
<li>The error callback argument (no exceptions): pass the error to a callback, a function provided specifically for handling errors and the results of asynchronous operations</li>
<li>pass the error to a reject Promise function</li>
</ul>
<p>在 Node.js 中错误处理主要有一下几种方法:</p>
<ul>
<li>callback(err, data) 回调约定</li>
<li>throw / try / catch</li>
<li>EventEmitter 的 error 事件</li>
</ul>
<p>callback(err, data) 这种形式的错误处理起来繁琐, 并不具备强制性, 目前已经处于仅需要了解, 不推荐使用的情况. 而 domain 模块则是半只脚踏进棺材了.</p>
<p>感谢 co 的先河, 现在的你已经简单的使用 try/catch 保护关键的位置, 以 koa 为例, 可以通过中间件的形式来进行错误处理, 详见 Koa error handling. 之后的 async/await 均属于这种模式.</p>
<p>通过 EventEmitter 的错误监听形式为各大关键的对象加上错误监听的回调. 例如监听 http server, tcp server 等对象的 error 事件以及 process 对象提供的 uncaughtException 和 unhandledRejection 等等.</p>
<p>使用 Promise 来封装异步, 并通过 Promise 的错误处理来 handle 错误.</p>
<p>如果上述办法不能起到良好的作用, 那么你需要学习如何优雅的 Let It Crash</p>
<h4 id="The-uncaught-exception"><a href="#The-uncaught-exception" class="headerlink" title="The uncaught exception"></a>The uncaught exception</h4><p>A Node process will terminate on any uncaught exception (explicit or implicit).</p>
<p>However, you can override this behavior by adding an uncaughtException handler on the process object. The following illustrates programmatically what Node does on your behalf when an uncaught exception occurs:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'uncaughtException'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">er</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(er.stack)</span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>An uncaughtException handler should be treated as a last opportunity to say your goodbyes before calling process.exit. It is not advised to keep the process running.</p>
<h3 id="The-unhandled-rejection"><a href="#The-unhandled-rejection" class="headerlink" title="The unhandled rejection"></a>The unhandled rejection</h3><p>Promises are ubiquitous in Node.js code and sometimes chained to a very long list of functions that return promises and so on. Not using a proper .catch(…) rejection handler will cause an unhandledRejection event to be emitted, and if not properly caught and inspected, you may rob yourself of your only chance to detect and possibly fix the problem. Here is how you can set up a listener:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">reason, promise</span>) </span>&#123;</span><br><span class="line">    logger.error(<span class="string">'Unhandled rejection'</span>, &#123;<span class="attr">reason</span>: reason, <span class="attr">promise</span>: promise&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>It is a good practice to set up a listener for an unhandledRejection event and log or even count the number of occurrences just to know what happened in your system and inspect possible instabilities due to improper rejection handling.</p>
<h3 id="The-infamous-‘error’-event"><a href="#The-infamous-‘error’-event" class="headerlink" title="The infamous ‘error’ event"></a>The infamous ‘error’ event</h3><p>Any EventEmitter can potentially emit an ‘error’ event and there are multiple objects that inherit from EventEmitters in Node (core and 3rd-party modules). The ‘error’ events emitted in Node core come from objects such as:</p>
<ul>
<li>Streams</li>
<li>Servers</li>
<li>Requests/Responses</li>
<li>Child processes</li>
</ul>
<p>Node treats this as a special event. If left unhandled, it will throw an exception (instead of silently ignoring the error).</p>
<p>Many 3rd-party modules will bubble up ‘error’ events or other errors from Node core modules as well as emit their own.</p>
<h3 id="Catching-implicit-exceptions"><a href="#Catching-implicit-exceptions" class="headerlink" title="Catching implicit exceptions"></a>Catching implicit exceptions</h3><p>We can’t forget about common implicit exceptions. A great example of this is the SyntaxError thrown when using JSON.parse: <code>JSON.parse(&#39;undefined&#39;)</code></p>
<p>These errors are avoided by a simple try/catch block:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  JSON.parse(maybeJSON)</span><br><span class="line">&#125; catch (er) &#123;</span><br><span class="line">  console.error(&apos;Invalid JSON&apos;, er)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Operational-errors-vs-programmer-errors"><a href="#Operational-errors-vs-programmer-errors" class="headerlink" title="Operational errors vs. programmer errors"></a>Operational errors vs. programmer errors</h2><p>Operational errors represent run-time problems experienced by correctly-written programs. These are not bugs in the program. In fact, these are usually problems with something else: the system itself (e.g., out of memory or too many open files), the system’s configuration (e.g., no route to a remote host), the network (e.g., socket hang-up), or a remote service (e.g., a 500 error, failure to connect, or the like). </p>
<p>Programmer errors are bugs in the program. These are things that can always be avoided by changing the code. They can never be handled properly (since by definition the code in question is broken).</p>
<p>Operational errors are error conditions that all correct programs must deal with, and as long as they’re dealt with, they don’t necessarily indicate a bug or even a serious problem.</p>
<p>By contrast, programmer errors are bugs. They’re cases where you made a mistake, maybe by forgetting to validate user input, mistyping a variable name, or something like that. By definition there’s no way to handle those.</p>
<p>This distinction is very important: operational errors are part of the normal operation of a program. Programmer errors are bugs.</p>
<h3 id="Handling-operational-errors"><a href="#Handling-operational-errors" class="headerlink" title="Handling operational errors"></a>Handling operational errors</h3><p>You may end up handling the same error at several levels of the stack. This happens when lower levels can’t do anything useful except propagate the error to their caller, which propagates the error to its caller, and so on. Often, only the top-level caller knows what the appropriate response is, whether that’s to retry the operation, report an error to the user, or something else. But that doesn’t mean you should try to report all errors to a single top-level callback, because that callback itself can’t know in what context the error occurred, what pieces of an operation have successfully completed, and which ones actually failed.</p>
<p>Let’s make this concrete. For any given error, there are a few things you might do:</p>
<ul>
<li>Deal with the failure directly</li>
<li>Propagate the failure to your client</li>
<li>Retry the operation</li>
<li>Blow up</li>
<li>Log the error — and do nothing else</li>
</ul>
<h3 id="Not-handling-programmer-errors"><a href="#Not-handling-programmer-errors" class="headerlink" title="(Not) handling programmer errors"></a>(Not) handling programmer errors</h3><p>Some people advocate attempting to recover from programmer errors — that is, allow the current operation to fail, but keep handling requests. This is not recommended. Consider that a programmer error is a case that you didn’t think about when you wrote the original code. How can you be sure that the problem won’t affect other requests? If other requests share any common state (a server, a socket, a pool of database connections, etc.), it’s very possible that the other requests will do the wrong thing.</p>
<p>The best way to recover from programmer errors is to crash immediately. You should run your programs using a restarter that will automatically restart the program in the event of a crash. With a restarter in place, crashing is the fastest way to restore reliable service in the face of a transient programmer error.</p>
<p>The best way to debug these problems is to configure Node to dump core on an uncaught exception.</p>
<p>Finally, remember that a programmer error on a server just becomes an operational error on a client. Clients have to deal with servers crashing and network blips. That’s not just theoretical — both really do happen in production systems.</p>
<h3 id="Patterns-for-writing-functions"><a href="#Patterns-for-writing-functions" class="headerlink" title="Patterns for writing functions"></a>Patterns for writing functions</h3><p>The single most important thing to do is document what your function does, including what arguments it takes (including their types and any other constraints), what it returns, what errors can happen, and what those errors mean. If you don’t know what errors can happen or don’t know what they mean, then your program cannot be correct except by accident. So if you’re writing a new function, you have to tell your callers what errors can happen and what they mean.</p>
<p>The general rule is that a function may deliver operational errors synchronously (e.g., by throwing) or asynchronously (by passing them to a callback or emitting error on an EventEmitter), but it should not do both.</p>
<h4 id="Bad-input-programmer-error-or-operational-error"><a href="#Bad-input-programmer-error-or-operational-error" class="headerlink" title="Bad input: programmer error or operational error?"></a>Bad input: programmer error or operational error?</h4><p>How do you know what’s a programmer error vs. an operational error? Quite simply: it’s up to you to define and document what types your function will allow and how you’ll try to interpret them. If you get something other than what you’ve documented to accept, that’s a programmer error. If the input is something you’ve documented to accept but you can’t process right now, that’s an operational error.</p>
<p>You have to use your judgment to decide how strict you want to be, but we can make some suggestions. To get specific, imagine a function called “connect” that takes an IP address and a callback and invokes the callback asynchronously after either succeeding or failing. Suppose the user passes something that’s obviously not a valid IP address, like ‘bob’. In this case, you have a few options:</p>
<p>Document that the function only accepts strings representing valid IPv4 addresses, and throw an exception immediately if the user passes ‘bob’. This is strongly recommended.<br>Document that the function accepts any string. If the user passes ‘bob’, emit an asynchronous error indicating that you couldn’t connect to IP address ‘bob’.</p>
<h4 id="Specific-recommendations-for-writing-new-functions"><a href="#Specific-recommendations-for-writing-new-functions" class="headerlink" title="Specific recommendations for writing new functions"></a>Specific recommendations for writing new functions</h4><ul>
<li>Be clear about what your function does.</li>
<li>Use Error objects (or subclasses) for all errors, and implement the Error contract.</li>
<li>Use the Error’s name property to distinguish errors programmatically.</li>
<li>Augment the Error object with properties that explain details<ul>
<li>通过使用 verror 这样的方式, 让 Error 一层层封装, 并在每一层将错误的信息一层层的包上, 最后拿到的 Error 直接可以从 message 中获取用于定位问题的关键信息.</li>
</ul>
</li>
<li>If you pass a lower-level error to your caller, consider wrapping it instead.</li>
</ul>
<p>An example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make a TCP connection to the given IPv4 address.  Arguments:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    ip4addr        a string representing a valid IPv4 address</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    tcpPort        a positive integer representing a valid TCP port</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    timeout        a positive integer denoting the number of milliseconds</span></span><br><span class="line"><span class="comment"> *                   to wait for a response from the remote server before</span></span><br><span class="line"><span class="comment"> *                   considering the connection to have failed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    callback       invoked when the connection succeeds or fails.  Upon</span></span><br><span class="line"><span class="comment"> *                   success, callback is invoked as callback(null, socket),</span></span><br><span class="line"><span class="comment"> *                   where `socket` is a Node net.Socket object.  Upon failure,</span></span><br><span class="line"><span class="comment"> *                   callback is invoked as callback(err) instead.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function may fail for several reasons:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    SystemError    For "connection refused" and "host unreachable" and other</span></span><br><span class="line"><span class="comment"> *                   errors returned by the connect(2) system call.  For these</span></span><br><span class="line"><span class="comment"> *                   errors, err.errno will be set to the actual errno symbolic</span></span><br><span class="line"><span class="comment"> *                   name.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    TimeoutError   Emitted if "timeout" milliseconds elapse without</span></span><br><span class="line"><span class="comment"> *                   successfully completing the connection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All errors will have the conventional "remoteIp" and "remotePort" properties.</span></span><br><span class="line"><span class="comment"> * After any error, any socket that was created will be closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">ip4addr, tcpPort, timeout, callback</span>) </span>&#123;</span><br><span class="line">  assert.equal(<span class="keyword">typeof</span> (ip4addr), <span class="string">'string'</span>,</span><br><span class="line">      <span class="string">"argument 'ip4addr' must be a string"</span>);</span><br><span class="line">  assert.ok(net.isIPv4(ip4addr),</span><br><span class="line">      <span class="string">"argument 'ip4addr' must be a valid IPv4 address"</span>);</span><br><span class="line">  assert.equal(<span class="keyword">typeof</span> (tcpPort), <span class="string">'number'</span>,</span><br><span class="line">      <span class="string">"argument 'tcpPort' must be a number"</span>);</span><br><span class="line">  assert.ok(!<span class="built_in">isNaN</span>(tcpPort) &amp;&amp; tcpPort &gt; <span class="number">0</span> &amp;&amp; tcpPort &lt; <span class="number">65536</span>,</span><br><span class="line">      <span class="string">"argument 'tcpPort' must be a positive integer between 1 and 65535"</span>);</span><br><span class="line">  assert.equal(<span class="keyword">typeof</span> (timeout), <span class="string">'number'</span>,</span><br><span class="line">      <span class="string">"argument 'timeout' must be a number"</span>);</span><br><span class="line">  assert.ok(!<span class="built_in">isNaN</span>(timeout) &amp;&amp; timeout &gt; <span class="number">0</span>,</span><br><span class="line">      <span class="string">"argument 'timeout' must be a positive integer"</span>);</span><br><span class="line">  assert.equal(<span class="keyword">typeof</span> (callback), <span class="string">'function'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* do work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你应该总是抛出一个继承自 JavaScript 内建的 Error 类型的对象，而不要抛出 String 或普通的 Object, 因为只有语言内建的 Error 对象上才会有调用栈，抛出其他类型的对象将可能会导致调用栈无法正确地被记录。同时也要慎重地使用自定义的异常类型，因为目前 JavaScript 中和调用栈有关的 API（如 Error.captureStackTrace）还不在标准中，各个引擎的实现也不同，你很难写出一个在所有引擎都可用的自定义异常类型。因此如果你的代码可能会同时运行在 Node.js 和浏览器中，或者你在编写一个开源项目，那么建议你不要使用自定义的异常类型；如果你的代码不是开源的，运行环境也非常确定，则可以考虑使用引擎提供的私有 API 来自定义异常类型。</p>
<p>传递异常的过程中的一些最佳实践：</p>
<ul>
<li>注意 Promise / callback chain 不要从中间断开</li>
<li>只处理已知的、必须在这里处理的异常，其他异常继续向外抛出</li>
<li>不要轻易地丢弃一个异常</li>
<li>传递的过程中可以向 err 对象上添加属性，补充上下文</li>
</ul>
<h2 id="Error-handling-with-Express"><a href="#Error-handling-with-Express" class="headerlink" title="Error handling with Express"></a>Error handling with Express</h2><p>Read this <a href="https://thecodebarbarian.com/80-20-guide-to-express-error-handling" target="_blank" rel="noopener">article</a>.</p>
<h2 id="Other-fun-stuff"><a href="#Other-fun-stuff" class="headerlink" title="Other fun stuff"></a>Other fun stuff</h2><ul>
<li><a href="https://medium.com/front-end-hacking/error-handling-in-node-javascript-suck-unless-you-know-this-2018-aa0a14cfdd9d" target="_blank" rel="noopener">Go style error handling</a></li>
</ul>
<h2 id="A-checklist"><a href="#A-checklist" class="headerlink" title="A checklist"></a>A checklist</h2><p>Errors happen; its important to build structures to handle them. Use this checklist to buff up your code:</p>
<ul>
<li>Where am I using throw? Am I prepared to handle these explicit exceptions when they occur?</li>
<li>Am I safeguarding against common sources for implicit exceptions (like JSON.parse, undefined data values in a nodeback)?</li>
<li>Am I handling ‘error’ events on all EventEmitters?</li>
<li>Am I handling all error arguments in nodebacks?</li>
<li>Am I notified of uncaught exceptions?</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://www.joyent.com/node-js/production/design/errors" target="_blank" rel="noopener">Error handling in Node.js</a></li>
<li><a href="https://goldbergyoni.com/checklist-best-practices-of-node-js-error-handling/" target="_blank" rel="noopener">Checklist: Best Practices of Node.JS Error Handling (2018)</a></li>
<li><a href="https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md" target="_blank" rel="noopener">ElemeFE/node-interview</a></li>
</ul>

    
	</div>
	<footer class="entry-footer">
		<div class="entry-meta-footer">
			<span class="category">
				
  <div class="article-category">
    <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
  </div>

			</span>
			<span class="tags">
				
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Best-Practices/">Best Practices</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Error-Handling/">Error Handling</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/">Node.js</a></li></ul>

			</span>
		</div>
	</footer>
	
    
<nav id="article-nav">
  
    <a href="/2018/07/08/aws-cloudfront/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          aws-cloudfront
        
      </div>
    </a>
  
  
    <a href="/2018/07/01/nodejs-logging/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          Node.js Logging Best Practices
        
      </div>
    </a>
  
</nav>

  
</article>




    </div>
    <div class="mb-search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="q" value="site:superliuwr.github.io">
  </form>
</div>
<footer id="footer">
	<h1 class="footer-blog-title">
		<a href="/">SUPERLOG</a>
	</h1>
	<span class="copyright">
		&copy; 2018 Marvin Liu<br>
		Modify from <a href="http://sanographix.github.io/tumblr/apollo/" target="_blank">Apollo</a> theme, designed by <a href="http://www.sanographix.net/" target="_blank">SANOGRAPHIX.NET</a><br>
		Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	</span>
</footer>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>